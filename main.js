// Generated by CoffeeScript 1.3.3
(function() {
  var Application, FLYMODE, FOG, NUM_BUILDINGS, PLAYER_HEIGHT, Utils, World, WorldPrimitives,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  PLAYER_HEIGHT = 300;

  FOG = true;

  NUM_BUILDINGS = 50;

  FLYMODE = true;

  Utils = (function() {

    function Utils() {}

    Utils.time = function(fn, label) {
      var start, x;
      if (label == null) {
        label = "";
      }
      start = new Date();
      x = fn();
      console.log("" + label + " elapsed in " + ((new Date() - start) / 1000) + "s");
      return x;
    };

    return Utils;

  })();

  WorldPrimitives = (function() {
    var material, nx, ny, nz, px, py, pz, spec;

    function WorldPrimitives() {}

    WorldPrimitives.cube_specs = (function() {
      var _i, _len, _ref, _results;
      _ref = [0, 1];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nx = _ref[_i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = [0, 1];
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            px = _ref1[_j];
            _results1.push((function() {
              var _k, _len2, _ref2, _results2;
              _ref2 = [0, 1];
              _results2 = [];
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                ny = _ref2[_k];
                _results2.push((function() {
                  var _l, _len3, _ref3, _results3;
                  _ref3 = [0, 1];
                  _results3 = [];
                  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                    py = _ref3[_l];
                    _results3.push((function() {
                      var _len4, _m, _ref4, _results4;
                      _ref4 = [0, 1];
                      _results4 = [];
                      for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
                        nz = _ref4[_m];
                        _results4.push((function() {
                          var _len5, _n, _ref5, _results5;
                          _ref5 = [0, 1];
                          _results5 = [];
                          for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
                            pz = _ref5[_n];
                            _results5.push({
                              nx: nx,
                              px: px,
                              ny: ny,
                              py: py,
                              nz: nz,
                              pz: pz
                            });
                          }
                          return _results5;
                        })());
                      }
                      return _results4;
                    })());
                  }
                  return _results3;
                })());
              }
              return _results2;
            })());
          }
          return _results1;
        })());
      }
      return _results;
    })();

    material = new THREE.MeshLambertMaterial({
      color: 0xff0000
    });

    WorldPrimitives.cubes = (function() {
      var _i, _len, _ref, _results;
      _ref = _.flatten(WorldPrimitives.cube_specs);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        spec = _ref[_i];
        _results.push(new THREE.CubeGeometry(100, 100, 100, 1, 1, 1, material, spec));
      }
      return _results;
    })();

    return WorldPrimitives;

  })();

  World = (function() {
    var getY, loadTexture,
      _this = this;

    function World(app, width, height, depth, sector_size) {
      var i, _i;
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.sector_size = sector_size;
      this.generate_terrain = __bind(this.generate_terrain, this);

      this.create_shadow = __bind(this.create_shadow, this);

      this.add_building = __bind(this.add_building, this);

      this.init_renderer = __bind(this.init_renderer, this);

      this.draw_sector = __bind(this.draw_sector, this);

      this.renderer = app.renderer, this.scene = app.scene, this.camera = app.camera;
      this.data = Utils.time(this.generate_terrain, "Generated terrain");
      for (i = _i = 0; 0 <= NUM_BUILDINGS ? _i <= NUM_BUILDINGS : _i >= NUM_BUILDINGS; i = 0 <= NUM_BUILDINGS ? ++_i : --_i) {
        this.add_building();
      }
      this.init_renderer();
    }

    World.prototype.draw_sector = function(x, y, resolution) {
      var cell, column, dx, dy, dz, geo, geometry, index, mesh, nx, ny, nz, px, py, pz, slice, _ref, _ref1, _ref2, _ref3;
      geometry = new THREE.Geometry();
      dx = x * this.sector_size;
      while (dx < (x + 1) * this.sector_size) {
        slice = this.data[dx];
        dy = y * this.sector_size;
        while (dy < (y + 1) * this.sector_size) {
          column = slice[dy];
          dz = 0;
          while (dz < column.length - 1) {
            cell = column[dz];
            if (cell === 1) {
              nx = !~~((_ref = this.data[dx - resolution]) != null ? _ref[dy][dz] : void 0);
              px = !~~((_ref1 = this.data[dx + resolution]) != null ? _ref1[dy][dz] : void 0);
              nz = !~~((_ref2 = slice[dy - resolution]) != null ? _ref2[dz] : void 0);
              pz = !~~((_ref3 = slice[dy + resolution]) != null ? _ref3[dz] : void 0);
              ny = !~~column[dz - resolution];
              py = !~~column[dz + resolution];
              index = nx * 32 + px * 16 + ny * 8 + py * 4 + nz * 2 + pz;
              if (index !== 0) {
                geo = WorldPrimitives.cubes[index];
                mesh = new THREE.Mesh(geo);
                mesh.scale.x = resolution;
                mesh.scale.y = resolution;
                mesh.scale.z = resolution;
                mesh.position.x = dx * 100;
                mesh.position.y = dz * 100;
                mesh.position.z = dy * 100;
                THREE.GeometryUtils.merge(geometry, mesh);
              }
            }
            dz += resolution;
          }
          dy += resolution;
        }
        dx += resolution;
      }
      geometry.mergeVertices();
      return geometry;
    };

    World.prototype.init_renderer = function() {
      var directionalLight, geometry, i, j, resolution, skybox,
        _this = this;
      this.camera.position.x = this.width * 100 / 2;
      this.camera.position.z = this.width * 100 / 2;
      if (FOG) {
        this.scene.fog = new THREE.FogExp2(0xff0000, 0.00002);
      }
      geometry = new THREE.Geometry();
      i = 0;
      while (i < 5) {
        j = 0;
        while (j < 5) {
          resolution = Math.pow(2, Math.max(Math.abs(2 - i), Math.abs(2 - j)));
          THREE.GeometryUtils.merge(geometry, Utils.time((function() {
            return _this.draw_sector(i, j, Math.ceil(resolution));
          }), "Generated geometry (" + i + ", " + j + ") at " + resolution));
          j++;
        }
        i++;
      }
      this.scene.add(new THREE.Mesh(geometry, new THREE.MeshFaceMaterial()));
      directionalLight = new THREE.DirectionalLight(0xff0000, 1);
      directionalLight.position.set(1, 1, 0.5);
      directionalLight.target.position.set(-1, -1, -0.5);
      this.scene.add(directionalLight);
      directionalLight = new THREE.DirectionalLight(0xff7c00, 2);
      directionalLight.position.set(0, 0, 1);
      this.scene.add(directionalLight);
      skybox = new THREE.Mesh(new THREE.SphereGeometry(90000, 60, 40), new THREE.MeshBasicMaterial({
        map: THREE.ImageUtils.loadTexture('skybox.png'),
        fog: false
      }));
      skybox.scale.x = -1;
      skybox.position = this.camera.position;
      return this.scene.add(skybox);
    };

    loadTexture = function(path, callback) {
      var image;
      image = new Image();
      image.onload = callback;
      image.src = path;
      return image;
    };

    World.prototype.add_building = function() {
      var width, x, xx, y, yy, zz, _i, _ref, _results;
      width = 10;
      x = Math.floor(Math.random() * (this.width - width));
      y = Math.floor(Math.random() * (this.height - width));
      console.log("" + x + " " + y);
      _results = [];
      for (xx = _i = x, _ref = x + width; x <= _ref ? _i <= _ref : _i >= _ref; xx = x <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (yy = _j = y, _ref1 = y + width; y <= _ref1 ? _j <= _ref1 : _j >= _ref1; yy = y <= _ref1 ? ++_j : --_j) {
            this.data[xx][yy] = (function() {
              var _k, _ref2, _results2;
              _results2 = [];
              for (zz = _k = 0, _ref2 = this.data[xx][yy].length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; zz = 0 <= _ref2 ? ++_k : --_k) {
                if (zz % 2 === 0) {
                  _results2.push(1);
                } else {
                  _results2.push(this.data[xx][yy][zz]);
                }
              }
              return _results2;
            }).call(this);
            _results1.push(this.data[xx][yy][this.depth - 1] = 0);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    World.prototype.create_shadow = function(x1, y1, z1, x2, y2, z2, s) {
      var shadow;
      shadow = new THREE.DirectionalLight(0x000000, 0);
      shadow.position.set(x1, y1, z1);
      shadow.target.position.set(x2, y2, z2);
      shadow.castShadow = true;
      shadow.shadowDarkness = 0.8;
      shadow.shadowCameraVisible = true;
      shadow.shadowCameraLeft = -s;
      shadow.shadowCameraRight = s;
      shadow.shadowCameraTop = s;
      shadow.shadowCameraBottom = -s;
      shadow.shadowCameraFar = 20000;
      shadow.shadowMapWidth = 4096;
      shadow.shadowMapHeight = 4096;
      shadow.shadowBias = 0.0005;
      return shadow;
    };

    World.prototype.generate_terrain = function() {
      var buffer, data, i, is_underground, item, j, max, min, perlin, quality, size, x, y, z, _i, _j, _len, _ref, _results;
      data = [];
      perlin = new ImprovedNoise();
      size = this.width * this.height;
      quality = 2;
      z = Math.random() * 100;
      j = 0;
      min = 10000000000;
      max = -10000000000;
      while (j < 4) {
        if (j === 0) {
          i = 0;
        }
        while (i < size) {
          data[i] = 0;
          i++;
        }
        i = 0;
        while (i < size) {
          x = i % this.width;
          y = ~~(i / this.width);
          data[i] += perlin.noise(x / quality, y / quality, z) * quality;
          i++;
        }
        quality *= 4;
        j++;
      }
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        min = Math.min(item, min);
        max = Math.max(item, max);
      }
      _results = [];
      for (x = _j = 0, _ref = this.width - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; x = 0 <= _ref ? ++_j : --_j) {
        _results.push((function() {
          var _k, _l, _ref1, _ref2, _results1;
          _results1 = [];
          for (y = _k = 0, _ref1 = this.height - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; y = 0 <= _ref1 ? ++_k : --_k) {
            is_underground = true;
            buffer = new UInt8Array(this.depth);
            for (z = _l = 0, _ref2 = this.depth - 1; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; z = 0 <= _ref2 ? ++_l : --_l) {
              if (z > ((data[x * this.width + y] - min) / (max - min)) * (this.depth - 30)) {
                is_underground = false;
              }
              if (is_underground) {
                buffer[z] = 1;
              } else {
                buffer[z] = 0;
              }
            }
            _results1.push(buffer);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    getY = function(x, z) {
      return ~~(data[x + z * World.world_width] * 0.2);
    };

    return World;

  }).call(this);

  Application = (function() {

    Application.prototype.container = document.getElementById("container");

    Application.prototype.renderer = new THREE.WebGLRenderer({
      clearColor: 0xff0000
    });

    Application.prototype.stats = new Stats();

    Application.prototype.clock = new THREE.Clock();

    Application.prototype.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 500000);

    Application.prototype.controls = void 0;

    Application.prototype.scene = new THREE.Scene();

    function Application() {
      this.onWindowResize = __bind(this.onWindowResize, this);

      this.render = __bind(this.render, this);

      this.animate = __bind(this.animate, this);
      this.controls = new THREE.FirstPersonControls(this.camera);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.autoClear = false;
      this.container.innerHTML = "";
      this.container.appendChild(this.renderer.domElement);
      this.stats.domElement.style.position = "absolute";
      this.stats.domElement.style.top = "0px";
      this.container.appendChild(this.stats.domElement);
      this.controls.movementSpeed = 1000;
      this.controls.lookSpeed = 0.125;
      this.controls.lookVertical = true;
      this.controls.constrainVertical = true;
      window.addEventListener("resize", this.onWindowResize, false);
      this.world = new World(this, 1000, 1000, 100, 200);
      setTimeout(this.animate, 0);
    }

    Application.prototype.gravity = 5;

    Application.prototype.delta_y = 0;

    Application.prototype.animate = function() {
      var column, ground, height, x, z;
      requestAnimationFrame(this.animate);
      x = Math.max(Math.floor((this.camera.position.x - 50) / 100), 0);
      z = Math.max(Math.floor((this.camera.position.z - 50) / 100), 0);
      column = this.world.data[x][z];
      if (!FLYMODE) {
        height = 0;
        while (column[height] === 1) {
          height++;
        }
        ground = (height * 100) + PLAYER_HEIGHT;
        if (this.camera.position.y > ground) {
          this.delta_y += this.gravity;
          this.camera.position.y -= this.delta_y;
          if (this.camera.position.y < ground) {
            this.camera.position.y = ground;
          }
        } else if (this.camera.position.y < ground) {
          this.delta_y = 0;
          this.camera.position.y = (ground - this.camera.position.y) * 0.5 + this.camera.position.y;
        }
      }
      this.render();
      return this.stats.update();
    };

    Application.prototype.render = function() {
      this.controls.update(this.clock.getDelta());
      return this.renderer.render(this.scene, this.camera);
    };

    Application.prototype.onWindowResize = function() {
      console.log("Resize event");
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      return this.controls.handleResize();
    };

    return Application;

  })();

  if (!Detector.webgl) {
    Detector.addGetWebGLMessage();
    document.getElementById("container").innerHTML = "";
  }

  window.onload = function() {
    return new Application;
  };

}).call(this);
